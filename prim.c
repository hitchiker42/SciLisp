/*****************************************************************
 * Copyright (C) 2013 Tucker DiNapoli                            *
 * SciLisp is Licensed under the GNU General Public License V3   *
 ****************************************************************/
/* This file is autogenerated do not edit */
/*"standard library" of SciLisp as it were.
 * used to all be in prim.h, split into prim.h as declarations and
 * the initPrims macro (which actually reads all these funcitons into
 * the global symbol table)
 * this file mostly defines basic binary operations, for more list functions
 * see cons.c/h and for array functions see array.c/h*/
#include "common.h"
#include "cons.h"
#include "array.h"
#include "print.h"
#include "prim.h"
#include "hash_fn.h"
#define binop_to_fun(op,fun_name)                                       \
  sexp fun_name(sexp x,sexp y){                                         \
    if((x.tag==y.tag)==_long){                                          \
      return                                                            \
        (sexp){.tag=_long,.val={.int64 = (x.val.int64 op y.val.int64)}}; \
    } else if(NUMBERP(x)&&NUMBERP(y)){                                  \
      register double xx=getDoubleVal(x);                               \
      register double yy=getDoubleVal(y);                               \
      return (sexp){.tag=_double,.val={.real64=(xx op yy)}};            \
    } else {                                                            \
      return error_sexp("type error in "#op);                           \
    }                                                                   \
  }
#define mkLisp_cmp(op,cname)                                    \
  sexp cname(sexp x,sexp y){                                    \
    if((x.tag == y.tag)==_long){                                \
      return (x.val.int64 op y.val.int64 ? LISP_TRUE : NIL);    \
    } else if(NUMBERP(x)&&NUMBERP(y)){                          \
      register double xx=getDoubleVal(x);                       \
      register double yy=getDoubleVal(y);                       \
      return (xx op yy ? LISP_TRUE : NIL);                      \
    } else {                                                    \
      return error_sexp("type error in "#op);                   \
    }                                                           \
  }
//ignore tags, allow logical operations on doubles(or anything else)
//be careful about this
#define lop_to_fun(op,fun_name)                                         \
  sexp fun_name(sexp x,sexp y){                                         \
    return (sexp){.tag=_long,.val={.int64=(x.val.int64 op y.val.int64)}}; \
  }
/*#define DEFUN(lname,cname,minargs,maxargs)                    \
  fxn_proto cname##call=                                        \
  { #cname, lname, minargs, maxargs, {.f##maxargs=cname}};*/
//  symbol c_name##mem[maxargs]={{.name="",.val=NIL_MACRO()}};
#define DEFUN(l_name,c_name,reqargs,optargs,keyargs,restarg,maxargs)  \
  function_args c_name##_args=                                            \
    { .num_req_args=reqargs,.num_opt_args=optargs,.num_keyword_args=keyargs, \
      .has_rest_arg=restarg,.args=0,.max_args=maxargs };      \
  function c_name##_call=                                             \
    { .args=&c_name##_args,.lname=#l_name,.cname=#c_name,                   \
      .comp = {.f##maxargs=c_name},            \
      .type = _compiled_fun };
#define MAKE_SYMBOL(l_name,c_name,hash_v)                               \
  symbol c_name ## _sym = {.name=l_name,.val={.tag=_fun,.val={.fun=0}}, \
                           .symbol_env=0};                              \
  symref c_name ## _ptr=0;                                              \
  obarray_entry c_name ##_ob_entry={.prev=0,.next=0,.ob_symbol=0,       \
                                    .hashv=hash_v}
//not sure if this has non constant initalizers or not
#define MAKE_CONSTANT(l_name,c_name)     \
  symbol c_name ## _sym = {.name=l_name,.val=c_name,.symbol_env=0};     \
  symref c_name ## _ptr = 0;                                           \
  obarray_entry c_name ##_ob_entry={.prev=0,.next=0,.ob_symbol=0,      \
                                      .hashv=0}
#define INIT_SYMBOL(c_name)                                    \
  c_name##_ptr=&c_name##_sym;                                  \
  c_name##_ptr->val.val.fun=&c_name##_call;                     \
  c_name##_ptr->symbol_env=ob_env;                              \
  c_name##_ob_entry.ob_symbol=c_name##_ptr;                     \
  prim_obarray_add_entry(ob,c_name##_ptr,&c_name##_ob_entry)
#define INIT_CONST(c_name)                      \
  c_name##_ptr=&c_name##_sym;                                   \
  c_name##_ptr->symbol_env=ob_env;                              \
  c_name##_ob_entry.ob_symbol=c_name##_ptr;                     \
  prim_obarray_add_entry(ob,c_name##_ptr,&c_name##_ob_entry)
#define MK_PREDICATE(lname,test)                \
  sexp lisp_##lname (sexp obj){                 \
    if(obj.tag == test){                        \
      return LISP_TRUE;                         \
    } else {                                    \
      return LISP_FALSE;                        \
    }                                           \
  }
#define MK_PREDICATE2(lname,test,test2)         \
  sexp lisp_##lname (sexp obj){                 \
    if(obj.tag == test || obj.tag == test2){    \
      return LISP_TRUE;                         \
    } else {                                    \
      return LISP_FALSE;                        \
    }                                           \
  }
#define MK_PREDICATE3(lname,test,test2,test3)                           \
  sexp lisp_##lname (sexp obj){                                         \
    if(obj.tag == test || obj.tag == test2 || obj.tag == test3){        \
      return LISP_TRUE;                                                 \
    } else {                                                            \
      return LISP_FALSE;                                                \
    }                                                                   \
  }
#define MK_PREDICATE4(lname,test,test2,test3,test4)                     \
  sexp lisp_##lname (sexp obj){                                         \
    if(obj.tag == test || obj.tag == test2 || obj.tag == test3 ||       \
       obj.tag == test4){                                               \
      return LISP_TRUE;                                                 \
    } else {                                                            \
      return LISP_FALSE;                                                \
    }                                                                   \
  }

#define mkMathFun1(cname,lispname)                                      \
  sexp lispname (sexp obj){                                             \
    if(!NUMBERP(obj)){return error_sexp("type error in "#lispname);}    \
    return (sexp){.tag=_double,.val={.real64 = cname(getDoubleVal(obj))}}; \
  }
#define mkMathFun2(cname,lispname)                              \
  sexp lispname(sexp x,sexp y){                                 \
    if(!NUMBERP(x)||!NUMBERP(y))                                \
      {return error_sexp("type error in "#lispname);}           \
    register double xx=getDoubleVal(x);                         \
    register double yy=getDoubleVal(y);                         \
    return (sexp){.tag=_double,.val={.real64 = cname(xx,yy)}};  \
  }
//create c functions for primitives
//arithmatic primitives
binop_to_fun(+,lisp_add);
binop_to_fun(-,lisp_sub);
binop_to_fun(*,lisp_mul);
binop_to_fun(/,lisp_div);
//bitwise primitives(need to add !)
lop_to_fun(^,lisp_xor);
lop_to_fun(>>,lisp_rshift);
lop_to_fun(<<,lisp_lshift);
lop_to_fun(&,lisp_logand);
lop_to_fun(|,lisp_logor);
//compairson primitives
mkLisp_cmp(>,lisp_gt);
mkLisp_cmp(<,lisp_lt);
mkLisp_cmp(>=,lisp_gte);
mkLisp_cmp(<=,lisp_lte);
mkLisp_cmp(!=,lisp_ne);
mkLisp_cmp(==,lisp_numeq);
//math primitives
mkMathFun2(pow,lisp_pow);
mkMathFun1(sqrt,lisp_sqrt);
mkMathFun1(cos,lisp_cos);
mkMathFun1(sin,lisp_sin);
mkMathFun1(tan,lisp_tan);
mkMathFun1(exp,lisp_exp);
mkMathFun1(log,lisp_log);
sexp lisp_abs(sexp x){
  if(x.tag==_long){return
      (sexp){.tag=_long,.val={.int64 = (labs(x.val.int64))}};
  } else if(x.tag == _double){
    return (sexp){.tag=_double,.val={.real64=fabs(x.val.real64)}};
  } else {
    return error_sexp("Argument to Abs must be a number");
  }
}
sexp lisp_mod(sexp x,sexp y){
  if((x.tag==y.tag)==_long){
    return (sexp){.tag=_long,.val={.int64 = (x.val.int64 % y.val.int64)}};
  } else if(NUMBERP(x) && NUMBERP(y)){
    register double xx=getDoubleVal(x);
    register double yy=getDoubleVal(y);
    return (sexp){.tag=_double,.val={.real64=fmod(xx,yy)}};
  } else {
    return error_sexp("Arguments to mod must be numbers");
  }
}
sexp ash(sexp x,sexp y){
  if(y.tag != _long || x.tag != _long){
    return error_sexp("arguments to ash must be integers");
  } else if(y.val.int64>=0){
    return lisp_rshift(x,y);
  } else{
    return lisp_lshift(x,(sexp){.tag=_long,.val={.int64 = (labs(y.val.int64))}});
  }
}
sexp lisp_randint(){
  return (sexp){.tag=_long,.val={.int64=mrand48()}};
}
sexp lisp_randfloat(sexp scale){
  double retval;
  if(scale.tag != _nil){
    retval=drand48()*getDoubleVal(scale);
  } else {
    retval = drand48();
  }
  return (sexp){.tag=_double,.val={.real64=retval}};
}
sexp lisp_eval(sexp obj){return eval(obj,topLevelEnv);}
sexp lisp_length(sexp obj){
  if(obj.len){
    return (sexp){.tag=_long,.val={.int64 = obj.len}};
  } else if (CONSP(obj)){
    return cons_length(obj);
  } else {
    return error_sexp("object does not have a meaningful length field");
  }
}
sexp lisp_round(sexp float_num,sexp mode){
  double double_val=getDoubleVal(float_num);
  if(double_val == NAN){
    return error_sexp("round argument is not a number");
  } else if(NILP(mode)){
    return long_sexp(lround(double_val));
  } else if(!(INTP(mode))){
        return error_sexp("rounding mode type error");
  } else {
    switch (mode.val.int64){
    //ceil,floor & trunc return doubles, there is a function
    //lrint which rounds to integers based on the current rounding mode
    //but because rounding modes are tricky we use a bit of a hack by
    //using lround to get an integer from the specified rounding function
      case -1:
        return long_sexp(lround(floor(double_val)));
      case 0:
        return long_sexp(lround(double_val));
      case 1:
        return long_sexp(lround(ceil(double_val)));
      case 2:
        return long_sexp(lround(trunc(double_val)));
      default:
        return error_sexp("round error,undefined rounding mode");
    }
  }
}
//should make this lisp_iota(a,b,c,d)
//where d is a switch to decide between a list or an array
sexp lisp_iota(sexp start,sexp stop,sexp step,sexp arrayorlist,sexp rnd){
  if(NILP(arrayorlist)){
    return list_iota(start, stop, step);
  } else {
    return array_iota(start,stop,step,rnd);
  }
}
void hello_world(){
  printf("hello, world!\n");
  return;
}
sexp lisp_inc(sexp num){
  if(!NUMBERP(num)){
    return error_sexp("cannot increment something that is not a number");
  } else switch(num.tag){
      case _long:
        return (sexp){.tag=num.tag,.len=num.len,.meta=num.meta,
            .val={.int64=(++num.val.int64)}};
      case _double:
        return (sexp){.tag=num.tag,.len=num.len,.meta=num.meta,
            .val={.real64=(++num.val.real64)}};
    }
}
sexp lisp_dec(sexp num){
  if(!NUMBERP(num)){
    return error_sexp("cannot increment something that is not a number");
  } else switch(num.tag){
      case _long:
        num.val.int64-=1;
        return num;
      case _double:
        num.val.real64-=1;
        return num;
    }
}
sexp lisp_min(sexp a,sexp b){
  if (!NUMBERP(a) || !(NUMBERP(b))){
    return error_sexp("arguments to min must be numbers");
  } if (a.tag == b.tag && a.tag==_long){
    return (a.val.int64 > b.val.int64?a:b);
  } else {
    return (getDoubleVal(a) > getDoubleVal(b)?a:b);
  }
}
sexp lisp_max(sexp a,sexp b){
  if (!NUMBERP(a) || !(NUMBERP(b))){
    return error_sexp("arguments to max must be numbers");
  } if (a.tag == b.tag && a.tag==_long){
    return (a.val.int64 < b.val.int64?a:b);
  } else {
    return (getDoubleVal(a) < getDoubleVal(b)?a:b);
  }
}
sexp lisp_open(sexp filename,sexp mode){
  if(NILP(mode)){
    mode=string_sexp("r");
  }
  if (!STRINGP(filename) || !(STRINGP(mode))){
    return error_sexp("arguments to open must be strings");
  }
  FILE* file = fopen(CORD_as_cstring(filename.val.cord),
                     CORD_as_cstring(mode.val.cord));
  if(file){
    return (sexp){.tag=_stream,.val={.stream=file}};
  } else {
    PRINT_MSG(filename.val.cord);
    PRINT_MSG(mode.val.cord);
    return_errno("fopen");
  }
}
sexp lisp_close(sexp stream){
  if(!STREAMP(stream)){
    return error_sexp("invalid file descriptor passed to close");
  } else {
    //fclose returns 0 on success and EOF on failure
    if(fclose(stream.val.stream)){
      return_errno("fclose");
    } else {
        return NIL;
    }
  }
}
sexp lisp_fputs(sexp string,sexp stream){
  if(!STREAMP(stream)){
    return error_sexp("invalid stream passed to fputs");
  } else if (!STRINGP(string)){
    return error_sexp("invalid string passed to fputs");
  } else if (string.tag == _str){
    fputs(CORD_as_cstring(string.val.cord),stream.val.stream);
  } else {//string must be a w_char string
    fputws(string.val.ustr,stream.val.stream);
  }
  return NIL;
}
sexp lisp_cat(sexp string,sexp rest){
  if(!STRINGP(string)){goto CAT_ERR;}
  CORD retval = string.val.cord;
  while(CONSP(rest)){
    if(!STRINGP(XCAR(rest))){goto CAT_ERR;}
    retval=CORD_cat(retval,XCAR(rest).val.cord);
    rest=XCDR(rest);
  }
  return (sexp){.tag = _str,.val={.cord=retval}};
  CAT_ERR:return error_sexp("arguments to cat must be strings");
}
sexp lisp_getcwd(){
  //probabaly not the most efficent way to do this
  char* temp_cwdname=get_current_dir_name();
  CORD cwdname=CORD_from_char_star(temp_cwdname);
  free(temp_cwdname);
  return (sexp){.tag=_str,.val={.cord=cwdname}};
}
sexp lisp_system_simple(sexp command){
  HERE();
  if(!STRINGP(command)){
    return error_sexp("argument to system must be a string");
  } else {
    int retval=system(command.val.cord);//should probably be CORD_as_cstring
    return long_sexp(retval);
  }
}
#define SHELL "/bin/bash"
sexp lisp_system(sexp command,sexp args){
  HERE();
  if(!STRINGP(command)){
  string_error:
    return error_sexp("arguments to system must be strings");
  } if(NILP(args)){
    //    return lisp_system_simple(command);
  }
  /*allocate arguments, suprisingly complicated */
  char **argv=alloca(16*sizeof(char*));//this should usually be enough
  argv[0]="bash";
  argv[1]="-c";
  argv[2]=CORD_as_cstring(command.val.cord);
  int i=3,maxargs=16;
  while(1){
    HERE();
    while(CONSP(args) && i<maxargs){
      HERE();
      if(!STRINGP(XCAR(args))){goto string_error;}
      argv[i]=CORD_as_cstring(XCAR(args).val.cord);
      args=XCDR(args);
      i++;
    } if(i<maxargs){break;}
    maxargs*=2;
    char** temp=alloca(maxargs*sizeof(char*));
    *temp=*argv;//? this seems somehow wrong
    argv=temp;
  }
  argv[i]=NULL;
  PRINT_MSG(argv[3]);
  //now to actually do what we came here for
  int status;
  pid_t pid;
  pid=fork();
  if(!pid){
    //we're in the child process now (fork returns 0 in child process)
    execv(SHELL,argv);//doesn't return
    _exit(EXIT_FAILURE);//if we get here something failed
    //we need to termin
  } else if (pid < 0) {//fork failed
    return_errno("fork");
  } else {//this is the parent process
    if(waitpid(pid,&status,0) != pid){
      return error_sexp
        ("the hell, I only forked one process, how'd we get here");
    } else {
      return long_sexp(status);
    }
  }
}
sexp arith_driver_simple(sexp required,sexp values,enum operator op){
  sexp(*f)(sexp,sexp);
  sexp retval;
  if(!(NUMBERP(required))){}
  switch(op){
    case _add:
      f=lisp_add;
      retval=required;
      break;
    case _sub:
      if(NILP(values)){
        if(INTP(required)){
          return (sexp){.tag=_long,.meta=required.meta,
              .val = {.int64 = (required.val.int64<0?
                                required.val.int64:
                                -required.val.int64)}};
        } else if(FLOATP(required)){
          return (sexp){.tag=_double,.meta=required.meta,
              .val = {.real64 = (required.val.real64<0?
                                required.val.real64:
                                -required.val.real64)}};
        } else {goto TYPE_ERROR;}
      } else {
        f=lisp_sub;
        retval=required;
      }
    case _mul:
      f=lisp_mul;
      retval=required;
    case _div:
      if(NILP(values)){
        if(NUMBERP(required)){
        return (sexp){.tag=_double,.meta=required.meta,
            .val={.real64=1/getDoubleVal(required)}};
        } else {goto TYPE_ERROR;}
      } else {
        f=lisp_div;
        retval=required;
      }
    case _min:
      f=lisp_min;
      retval=required;
    case _max:
      f=lisp_max;
      retval=required;
      //do bitwise stuff
  }
  while(CONSP(values)){
    retval=f(retval,XCAR(values));
    values=XCDR(values);
    if(ERRORP(retval)){
      goto TYPE_ERROR;
    }
  }
  return retval;
 TYPE_ERROR:
  return error_sexp("Type error");
}
sexp lisp_sum(sexp required,sexp values){
  if(!CONSP(values) && !NILP(values)){
    return error_sexp("this shouldn't happen, rest arg to sum is not a list or nil");
  } else {
    switch (required.tag){
      case _double:{
        sexp result= required;
        while(CONSP(values)){
          result.val.real64 += getDoubleVal(XCAR(values));
          values = XCDR(values);
        }
        return result;
      }
      case _long:{
        sexp result = required;
        while(CONSP(values)){
          //unsafe, but assume if the first arg is a long they all are
          result.val.int64 += XCAR(values).val.int64;
          values=XCDR(values);
        }
        return result;
      }
      default:
        return error_sexp("args to sum must be numbers");
    }
  }
}
//just call a c function, unsafe, no typechecking and not very user frendly
//argtypes should be either keyword symbols or literal types
sexp ccall(sexp function,sexp libname,sexp rettype,sexp argtypes,sexp args){
  if(!STRINGP(function) || !(STRINGP(libname)) || !(CONSP(argtypes))
     || !(CONSP(args))){
    return error_sexp("type error in ccall");
  }
  char* dllibname;
  void* dllib;
  if(CORD_cmp(CORD_substr(libname.val.cord,0,3),"lib")){
    dllibname=(char*)CORD_to_const_char_star(CORD_cat(libname.val.cord,".so"));
  } else {
    dllibname=(char*)CORD_to_const_char_star
      (CORD_catn(3,"lib",libname.val.cord,".so"));
  }
  dllib=dlopen(dllibname,0);
  return NIL;
}
sexp lisp_eq(sexp obj1,sexp obj2){
  if(BIGNUMP(obj1) && BIGNUMP(obj2)){
    if(NUMBERP(obj1) && NUMBERP(obj2)){
      return lisp_numeq(obj1,obj2);
    } else {
      //define this first
      //      return lisp_bignumeq(obj1,obj2);
    }
  }
  if(obj1.tag != obj2.tag){
    return LISP_FALSE;
  }
  switch(obj1.tag){
    case _cons:
    case _list:
    case _sym:
    case _array:
    case _str:
    case _lenv:
    case _funarg:
    case _keyword:
      return (obj1.val.int64 == obj2.val.int64 ? LISP_TRUE : LISP_FALSE);
    case _type:
    case _special:
      return (obj1.val.meta == obj2.val.meta ? LISP_TRUE : LISP_FALSE);
    default:
      return LISP_FALSE;
  }
}
sexp lisp_eql(sexp obj1,sexp obj2);
sexp lisp_apply(sexp fun,sexp args){
  if(!FUNCTIONP(fun)){
    return error_sexp("first argument to apply should be a funciton");
  }
  cons* arglist=alloca(fun.val.fun->args->max_args*sizeof(sexp));
}
/*probably eaiser in lisp
  (defun ++! (x) (setq x (+1 x)))
  (defun --! (x) (setq x (-1 x)))
*/
#define lisp_stderr {.tag = _stream,.val={.stream=stderr}}
#define lisp_stdout {.tag = _stream,.val={.stream=stdout}}
#define lisp_stdin {.tag = _stream,.val={.stream=stdin}}
#define lisp_mach_eps  {.tag=_double,.val={.real64=1.41484755040568800000e-16}}
#define lisp_pi  {.tag=_double,.val={.real64=3.14159265358979323846}}
#define lisp_euler {.tag=_double,.val={.real64=2.7182818284590452354}}
#define lisp_max_long  {.tag=_long,.val={.int64=LONG_MAX}}
#define lisp_double_0  {.tag=_double,.val={.real64=0.0}}
#define lisp_double_1  {.tag=_double,.val={.real64=1.0}}
#define lisp_long_0  {.tag=_long,.val={.int64=0}}
#define lisp_long_1  {.tag=_long,.val={.int64=1}}
//allocating static space for pointers, not actually initalizing constants
#define lisp_bigint_0  {.tag=_bigint,.val={.bigint=0}}
#define lisp_bigint_1  {.tag=_bigint,.val={.bigint=0}}
#define lisp_bigfloat_0   {.tag=_bigfloat,.val={.bigfloat=0}}
#define lisp_bigfloat_1   {.tag=_bigfloat,.val={.bigfloat=0}}
#define lisp_NIL {.tag = -1,.val={.int64 = 0}}
#define lisp_LISP_TRUE {.tag = -2,.val={.meta = 11}}
#define lisp_LISP_FALSE {.tag = -3,.val={.meta = -3}}

MK_PREDICATE3(consp,_cons,_list,_dpair);
MK_PREDICATE2(numberp,_long,_double);
MK_PREDICATE(arrayp,_array);
MK_PREDICATE(nilp,_nil);
MK_PREDICATE(symbolp,_sym);
MK_PREDICATE(bigintp,_bigint);
MK_PREDICATE(bigfloatp,_bigfloat);
MK_PREDICATE2(stringp,_str,_ustr);
MK_PREDICATE4(bignump,_bigint,_bigfloat,_long,_double);
MK_PREDICATE(errorp,_error);
MK_PREDICATE(functionp,_fun);
MK_PREDICATE(streamp,_stream);
DEFUN("+",lisp_add,2,0,0,0,2);
DEFUN("-",lisp_sub,2,0,0,0,2);
DEFUN("*",lisp_mul,2,0,0,0,2);
DEFUN("/",lisp_div,2,0,0,0,2);
DEFUN("<",lisp_lt,2,0,0,0,2);
DEFUN(">",lisp_gt,2,0,0,0,2);
DEFUN(">=",lisp_gte,2,0,0,0,2);
DEFUN("<=",lisp_lte,2,0,0,0,2);
DEFUN("!=",lisp_ne,2,0,0,0,2);
DEFUN("=",lisp_numeq,2,0,0,0,2);
DEFUN("++",lisp_inc,1,0,0,0,1);
DEFUN("--",lisp_dec,1,0,0,0,1);
DEFUN("sum",lisp_sum,1,0,0,1,2);
DEFUN("cons",Cons,2,0,0,0,2);
DEFUN("set-car!",set_car,2,0,0,0,2);
DEFUN("set-cdr!",set_cdr,2,0,0,0,2);
DEFUN("last",last,1,0,0,0,1);
DEFUN("push!",push_cons,2,0,0,0,2);
DEFUN("pop!",pop_cons,1,0,0,0,1);
DEFUN("mapcar",mapcar,2,0,0,0,2);
DEFUN("reduce",reduce,2,0,0,0,2);
DEFUN("qsort!",qsort_cons,2,0,0,0,2);
DEFUN("length",lisp_length,1,0,0,0,1);
DEFUN("iota",lisp_iota,1,4,0,0,5);
DEFUN("aref",aref,2,0,0,0,2);
DEFUN("array->list",array_to_list,1,0,0,0,1);
DEFUN("typeName",lisp_typeName,1,0,0,0,1);
DEFUN("typeOf",typeOf,1,0,0,0,1);
DEFUN("print",lisp_print,1,0,0,0,1);
DEFUN("println",lisp_println,1,0,0,0,1);
DEFUN("eval",lisp_eval,1,0,0,0,1);
DEFUN("fopen",lisp_open,1,1,0,0,2);
DEFUN("fclose",lisp_close,1,0,0,0,1);
DEFUN("fputs",lisp_fputs,2,0,0,0,2);
DEFUN("fprint",lisp_fprint,2,0,0,0,2);
DEFUN("fprintln",lisp_fprintln,2,0,0,0,2);
DEFUN("cat",lisp_cat,1,0,0,1,2);
DEFUN("pwd",lisp_getcwd,0,0,0,0,0);
DEFUN("system",lisp_system,1,0,0,1,2);
DEFUN("eq",lisp_eq,2,0,0,0,2);
DEFUN("logxor",lisp_xor,2,0,0,0,2);
DEFUN("logand",lisp_logand,2,0,0,0,2);
DEFUN("logor",lisp_logor,2,0,0,0,2);
DEFUN("ash",ash,2,0,0,0,2);
DEFUN("expt",lisp_pow,2,0,0,0,2);
DEFUN("sqrt",lisp_sqrt,1,0,0,0,1);
DEFUN("cos",lisp_cos,1,0,0,0,1);
DEFUN("sin",lisp_sin,1,0,0,0,1);
DEFUN("tan",lisp_tan,1,0,0,0,1);
DEFUN("exp",lisp_exp,1,0,0,0,1);
DEFUN("log",lisp_log,1,0,0,0,1);
DEFUN("abs",lisp_abs,1,0,0,0,1);
DEFUN("mod",lisp_mod,2,0,0,0,2);
DEFUN("min",lisp_min,2,0,0,0,2);
DEFUN("max",lisp_max,2,0,0,0,2);
DEFUN("round",lisp_round,1,0,0,0,2);
DEFUN("drand",lisp_randfloat,0,1,0,0,1);
DEFUN("lrand",lisp_randint,0,0,0,0,0);
DEFUN("bigint",lisp_bigint,1,0,0,0,1);
DEFUN("bigfloat",lisp_bigfloat,1,2,0,0,3);
DEFUN("bigint-add",lisp_bigint_add,2,0,0,0,2);
DEFUN("bigint-sub",lisp_bigint_sub,2,0,0,0,2);
DEFUN("bigint-mul",lisp_bigint_mul,2,0,0,0,2);
DEFUN("bigint-mod",lisp_bigint_mod,2,0,0,0,2);
DEFUN("bigint-cdiv_q",lisp_bigint_cdiv_q,2,0,0,0,2);
DEFUN("bigint-fdiv_q",lisp_bigint_fdiv_q,2,0,0,0,2);
DEFUN("bigint-tdiv_q",lisp_bigint_tdiv_q,2,0,0,0,2);
DEFUN("bigint-cdiv_r",lisp_bigint_cdiv_r,2,0,0,0,2);
DEFUN("bigint-fdiv_r",lisp_bigint_fdiv_r,2,0,0,0,2);
DEFUN("bigint-tdiv_r",lisp_bigint_tdiv_r,2,0,0,0,2);
DEFUN("bigint-and",lisp_bigint_and,2,0,0,0,2);
DEFUN("bigint-ior",lisp_bigint_ior,2,0,0,0,2);
DEFUN("bigint-xor",lisp_bigint_xor,2,0,0,0,2);
DEFUN("bigint-gt",lisp_bigint_gt,2,0,0,0,2);
DEFUN("bigint-eq",lisp_bigint_eq,2,0,0,0,2);
DEFUN("bigint-lt",lisp_bigint_lt,2,0,0,0,2);
DEFUN("bigint-ge",lisp_bigint_ge,2,0,0,0,2);
DEFUN("bigint-le",lisp_bigint_le,2,0,0,0,2);
DEFUN("bigint-ne",lisp_bigint_ne,2,0,0,0,2);
DEFUN("bigfloat-add",lisp_bigfloat_add,2,0,0,0,2);
DEFUN("bigfloat-sub",lisp_bigfloat_sub,2,0,0,0,2);
DEFUN("bigfloat-mul",lisp_bigfloat_mul,2,0,0,0,2);
DEFUN("bigfloat-div",lisp_bigfloat_div,2,0,0,0,2);
DEFUN("bigfloat-pow",lisp_bigfloat_pow,2,0,0,0,2);
DEFUN("bigfloat-gt",lisp_bigfloat_gt,2,0,0,0,2);
DEFUN("bigfloat-eq",lisp_bigfloat_eq,2,0,0,0,2);
DEFUN("bigfloat-lt",lisp_bigfloat_lt,2,0,0,0,2);
DEFUN("bigfloat-ge",lisp_bigfloat_ge,2,0,0,0,2);
DEFUN("bigfloat-le",lisp_bigfloat_le,2,0,0,0,2);
DEFUN("bigfloat-ne",lisp_bigfloat_ne,2,0,0,0,2);
DEFUN("arrayp",lisp_arrayp,1,0,0,0,1);
DEFUN("consp",lisp_consp,1,0,0,0,1);
DEFUN("numberp",lisp_numberp,1,0,0,0,1);
DEFUN("nilp",lisp_nilp,1,0,0,0,1);
DEFUN("symbolp",lisp_symbolp,1,0,0,0,1);
DEFUN("bigintp",lisp_bigintp,1,0,0,0,1);
DEFUN("bigfloatp",lisp_bigfloatp,1,0,0,0,1);
DEFUN("stringp",lisp_stringp,1,0,0,0,1);
DEFUN("bignump",lisp_bignump,1,0,0,0,1);
DEFUN("errorp",lisp_errorp,1,0,0,0,1);
DEFUN("functionp",lisp_functionp,1,0,0,0,1);
DEFUN("streamp",lisp_streamp,1,0,0,0,1);
DEFUN("cdr",cdr,1,0,0,0,1);
DEFUN("cddr",cddr,1,0,0,0,1);
DEFUN("cdddr",cdddr,1,0,0,0,1);
DEFUN("cddddr",cddddr,1,0,0,0,1);
DEFUN("cdddar",cdddar,1,0,0,0,1);
DEFUN("cddar",cddar,1,0,0,0,1);
DEFUN("cddadr",cddadr,1,0,0,0,1);
DEFUN("cddaar",cddaar,1,0,0,0,1);
DEFUN("cdar",cdar,1,0,0,0,1);
DEFUN("cdadr",cdadr,1,0,0,0,1);
DEFUN("cdaddr",cdaddr,1,0,0,0,1);
DEFUN("cdadar",cdadar,1,0,0,0,1);
DEFUN("cdaar",cdaar,1,0,0,0,1);
DEFUN("cdaadr",cdaadr,1,0,0,0,1);
DEFUN("cdaaar",cdaaar,1,0,0,0,1);
DEFUN("car",car,1,0,0,0,1);
DEFUN("cadr",cadr,1,0,0,0,1);
DEFUN("caddr",caddr,1,0,0,0,1);
DEFUN("cadddr",cadddr,1,0,0,0,1);
DEFUN("caddar",caddar,1,0,0,0,1);
DEFUN("cadar",cadar,1,0,0,0,1);
DEFUN("cadadr",cadadr,1,0,0,0,1);
DEFUN("cadaar",cadaar,1,0,0,0,1);
DEFUN("caar",caar,1,0,0,0,1);
DEFUN("caadr",caadr,1,0,0,0,1);
DEFUN("caaddr",caaddr,1,0,0,0,1);
DEFUN("caadar",caadar,1,0,0,0,1);
DEFUN("caaar",caaar,1,0,0,0,1);
DEFUN("caaadr",caaadr,1,0,0,0,1);
DEFUN("caaaar",caaaar,1,0,0,0,1);
#undef DEFUN
MAKE_SYMBOL("+",lisp_add,0xfe1176257ade3f65 );
MAKE_SYMBOL("-",lisp_sub,0x62c6c42523166e74 );
MAKE_SYMBOL("*",lisp_mul,0x21df3c258f79be90 );
MAKE_SYMBOL("/",lisp_div,0xd2eec725627cb9a1 );
MAKE_SYMBOL("<",lisp_lt,0x3b9b0bf59c649ce );
MAKE_SYMBOL(">",lisp_gt,0x39aa2bf59ab8175 );
MAKE_SYMBOL(">=",lisp_gte,0xcb439b255e6c4e30 );
MAKE_SYMBOL("<=",lisp_lte,0x1ad100258bef2d91 );
MAKE_SYMBOL("!=",lisp_ne,0x3b29dbf59c00ad7 );
MAKE_SYMBOL("=",lisp_numeq,0x857a51d9ec2a1750 );
MAKE_SYMBOL("++",lisp_inc,0x45d5e725a43814ee );
MAKE_SYMBOL("--",lisp_dec,0xd2c5b225625990de );
MAKE_SYMBOL("sum",lisp_sum,0x62c6bb2523165f29 );
MAKE_SYMBOL("cons",Cons,0x3658069d1acdf568 );
MAKE_SYMBOL("set-car!",set_car,0x1901921ef1b17f2a );
MAKE_SYMBOL("set-cdr!",set_cdr,0x18f77c1ef1a90543 );
MAKE_SYMBOL("last",last,0x456d2ad905847d9 );
MAKE_SYMBOL("push!",push_cons,0xdeb98901efbd89cb );
MAKE_SYMBOL("pop!",pop_cons,0x69c73c4f15772b00 );
MAKE_SYMBOL("mapcar",mapcar,0xc0ee7f3d3740c6c5 );
MAKE_SYMBOL("reduce",reduce,0x2f92df0bac03dce7 );
MAKE_SYMBOL("qsort!",qsort_cons,0x9ece1ff7e6e56498 );
MAKE_SYMBOL("length",lisp_length,0x8f69728654de2182 );
MAKE_SYMBOL("iota",lisp_iota,0xdae23af6073c56d5 );
MAKE_SYMBOL("aref",aref,0x89502d843ec2b711 );
MAKE_SYMBOL("array->list",array_to_list,0x3dd759e226ade7d3 );
MAKE_SYMBOL("typeName",lisp_typeName,0x3fd978c7b7c570e5 );
MAKE_SYMBOL("typeOf",typeOf,0x6971003f4c928aa0 );
MAKE_SYMBOL("print",lisp_print,0x4a38f2ac6b3b6ed1 );
MAKE_SYMBOL("println",lisp_println,0x41fd0729bd308d0b );
MAKE_SYMBOL("eval",lisp_eval,0x4be31a91624eed18 );
MAKE_SYMBOL("fopen",lisp_open,0x9ad6eac17558fa36 );
MAKE_SYMBOL("fclose",lisp_close,0x5fd43b5b8cc8b872 );
MAKE_SYMBOL("fputs",lisp_fputs,0x6ea4ff6635a99296 );
MAKE_SYMBOL("fprint",lisp_fprint,0xde93ad9559a71957 );
MAKE_SYMBOL("fprintln",lisp_fprintln,0xd37b5eb8b9983cdd );
MAKE_SYMBOL("cat",lisp_cat,0xef5542257341657a );
MAKE_SYMBOL("pwd",lisp_getcwd,0x3c07edcc2db7ada8 );
MAKE_SYMBOL("system",lisp_system,0x261ca996c6e4a97 );
MAKE_SYMBOL("eq",lisp_eq,0x3a1a9bf59b1ac08 );
MAKE_SYMBOL("logxor",lisp_xor,0xb1cc27255025b0d7 );
MAKE_SYMBOL("logand",lisp_logand,0xbe33926eae30db1d );
MAKE_SYMBOL("logor",lisp_logor,0xf6602a2681c26321 );
MAKE_SYMBOL("ash",ash,0xe759a1190572cddf );
MAKE_SYMBOL("expt",lisp_pow,0x6d8fca2529cc0cb0 );
MAKE_SYMBOL("sqrt",lisp_sqrt,0x11e3ff1ab3a56bb4 );
MAKE_SYMBOL("cos",lisp_cos,0xef262d257319d109 );
MAKE_SYMBOL("sin",lisp_sin,0x62ef9825233928c4 );
MAKE_SYMBOL("tan",lisp_tan,0x49151f25149e0591 );
MAKE_SYMBOL("exp",lisp_exp,0xdd47de2568d36d09 );
MAKE_SYMBOL("log",lisp_log,0x1a7c0e258ba7055c );
MAKE_SYMBOL("abs",lisp_abs,0xfe2687257af0b852 );
MAKE_SYMBOL("mod",lisp_mod,0x21cb28258f68f38a );
MAKE_SYMBOL("min",lisp_min,0x21b63e258f56bce2 );
MAKE_SYMBOL("max",lisp_max,0x219b28258f3fcfc8 );
MAKE_SYMBOL("round",lisp_round,0xe7863c8b43d1dc8e );
MAKE_SYMBOL("drand",lisp_randfloat,0xd7a3e2a6c9ca3a5d );
MAKE_SYMBOL("lrand",lisp_randint,0xcffb580fd3c7c16 );
MAKE_SYMBOL("bigint",lisp_bigint,0x6a031ae6deb3b2f9 );
MAKE_SYMBOL("bigfloat",lisp_bigfloat,0xbf028d8fe03cb0c2 );
MAKE_SYMBOL("bigint-add",lisp_bigint_add,0xfce0adb9b6369069 );
MAKE_SYMBOL("bigint-sub",lisp_bigint_sub,0x6195c3b95e6e6050 );
MAKE_SYMBOL("bigint-mul",lisp_bigint_mul,0x65c37bb9f1e3140c );
MAKE_SYMBOL("bigint-mod",lisp_bigint_mod,0x657877b9f1a321c6 );
MAKE_SYMBOL("bigint-cdiv_q",lisp_bigint_cdiv_q,0xb7d4dd2abcb7212e );
MAKE_SYMBOL("bigint-fdiv_q",lisp_bigint_fdiv_q,0xf45a3b87940c2a3 );
MAKE_SYMBOL("bigint-tdiv_q",lisp_bigint_tdiv_q,0x591c53a0f7cdeaad );
MAKE_SYMBOL("bigint-cdiv_r",lisp_bigint_cdiv_r,0xb7d4dc2abcb71f7b );
MAKE_SYMBOL("bigint-fdiv_r",lisp_bigint_fdiv_r,0xf45a4b87940c456 );
MAKE_SYMBOL("bigint-tdiv_r",lisp_bigint_tdiv_r,0x591c50a0f7cde594 );
MAKE_SYMBOL("bigint-and",lisp_bigint_and,0xfccb89b9b623f733 );
MAKE_SYMBOL("bigint-ior",lisp_bigint_ior,0x44d6edb9dfb9b948 );
MAKE_SYMBOL("bigint-xor",lisp_bigint_xor,0xb13e26b98c080403 );
MAKE_SYMBOL("bigint-gt",lisp_bigint_gt,0x3e4dec1dda30bfc1 );
MAKE_SYMBOL("bigint-eq",lisp_bigint_eq,0x3e54db1dda36c18c );
MAKE_SYMBOL("bigint-lt",lisp_bigint_lt,0x3e6cea1dda4b6cea );
MAKE_SYMBOL("bigint-ge",lisp_bigint_ge,0x3e4ddb1dda30a2de );
MAKE_SYMBOL("bigint-le",lisp_bigint_le,0x3e6cfb1dda4b89cd );
MAKE_SYMBOL("bigint-ne",lisp_bigint_ne,0x3e65e71dda454923 );
MAKE_SYMBOL("bigfloat-add",lisp_bigfloat_add,0x5ce208f741cde6d2 );
MAKE_SYMBOL("bigfloat-sub",lisp_bigfloat_sub,0xd42552f784c9600b );
MAKE_SYMBOL("bigfloat-mul",lisp_bigfloat_mul,0x7d86d2f753b9f1e7 );
MAKE_SYMBOL("bigfloat-div",lisp_bigfloat_div,0x402c9bf730c57e72 );
MAKE_SYMBOL("bigfloat-pow",lisp_bigfloat_pow,0xed99e0f7930df3bb );
MAKE_SYMBOL("bigfloat-gt",lisp_bigfloat_gt,0xc379321cd0ffa27c );
MAKE_SYMBOL("bigfloat-eq",lisp_bigfloat_eq,0xc3803b1cd105d075 );
MAKE_SYMBOL("bigfloat-lt",lisp_bigfloat_lt,0xc39f341cd120751f );
MAKE_SYMBOL("bigfloat-ge",lisp_bigfloat_ge,0xc379231cd0ff88ff );
MAKE_SYMBOL("bigfloat-le",lisp_bigfloat_le,0xc39f431cd1208e9c );
MAKE_SYMBOL("bigfloat-ne",lisp_bigfloat_ne,0xc398371cd11a5b8a );
MAKE_SYMBOL("arrayp",lisp_arrayp,0x7d808d48023e869d );
MAKE_SYMBOL("consp",lisp_consp,0x13ff0f42de4882d1 );
MAKE_SYMBOL("numberp",lisp_numberp,0x6066daab1874f889 );
MAKE_SYMBOL("nilp",lisp_nilp,0x70c241ba833a3987 );
MAKE_SYMBOL("symbolp",lisp_symbolp,0x82929922881de33a );
MAKE_SYMBOL("bigintp",lisp_bigintp,0xd6f93f4c6b585ecb );
MAKE_SYMBOL("bigfloatp",lisp_bigfloatp,0xce073d7a07203e76 );
MAKE_SYMBOL("stringp",lisp_stringp,0x4820d35f103b77f5 );
MAKE_SYMBOL("bignump",lisp_bignump,0x5675ae7650a07788 );
MAKE_SYMBOL("errorp",lisp_errorp,0xe2d56335abc40230 );
MAKE_SYMBOL("functionp",lisp_functionp,0xcfa48bf2151e142e );
MAKE_SYMBOL("streamp",lisp_streamp,0x83fb04c416f51082 );
MAKE_SYMBOL("cdr",cdr,0xf5ecf3190cecd5b0 );
MAKE_SYMBOL("cddr",cddr,0xce54d590f6525240 );
MAKE_SYMBOL("cdddr",cdddr,0xecc417528e219670 );
MAKE_SYMBOL("cddddr",cddddr,0x72a7a34782f4ff00 );
MAKE_SYMBOL("cdddar",cdddar,0x729db54782ecc911 );
MAKE_SYMBOL("cddar",cddar,0xecba29528e196081 );
MAKE_SYMBOL("cddadr",cddadr,0x5985324774f6a6bf );
MAKE_SYMBOL("cddaar",cddaar,0x5974384774e83dbe );
MAKE_SYMBOL("cdar",cdar,0xce4ae790f64a1c51 );
MAKE_SYMBOL("cdadr",cdadr,0xd3a0a65280218b2f );
MAKE_SYMBOL("cdaddr",cdaddr,0xbb48f32fb8cc1351 );
MAKE_SYMBOL("cdadar",cdadar,0xbb52e12fb8d44940 );
MAKE_SYMBOL("cdaar",cdaar,0xd38fac528013222e );
MAKE_SYMBOL("cdaadr",cdaadr,0x90141c2fa05a2362 );
MAKE_SYMBOL("cdaaar",cdaaar,0x900a262fa051dfdb );
MAKE_SYMBOL("car",car,0xf5e305190ce49fc1 );
MAKE_SYMBOL("cadr",cadr,0xb5316490e85246ff );
MAKE_SYMBOL("caddr",caddr,0x3564673ac3f6f7c1 );
MAKE_SYMBOL("cadddr",cadddr,0xb06323dafc7dceff );
MAKE_SYMBOL("caddar",caddar,0xb05229dafc6f65fe );
MAKE_SYMBOL("cadar",cadar,0x356e553ac3ff2db0 );
MAKE_SYMBOL("cadadr",cadadr,0xc98694db0a7dda40 );
MAKE_SYMBOL("cadaar",cadaar,0xc97ca6db0a75a451 );
MAKE_SYMBOL("caar",caar,0xb5206a90e843ddfe );
MAKE_SYMBOL("caadr",caadr,0xa30903aab86bad2 );
MAKE_SYMBOL("caaddr",caaddr,0xd761b3b1760c0446 );
MAKE_SYMBOL("caadar",caadar,0xd772cdb1761aa3a7 );
MAKE_SYMBOL("caaar",caaar,0xa259a3aab7cc44b );
MAKE_SYMBOL("caaadr",caaadr,0xbaf452b1654165ed );
MAKE_SYMBOL("caaaar",caaaar,0xbae350b16532ef54 );
MAKE_CONSTANT("Meps",lisp_mach_eps);
MAKE_CONSTANT("pi",lisp_pi);
MAKE_CONSTANT("e",lisp_euler);
MAKE_CONSTANT("max_long",lisp_max_long);
MAKE_CONSTANT("nil",lisp_NIL);
MAKE_CONSTANT("t",lisp_LISP_TRUE);
MAKE_CONSTANT("#f",lisp_LISP_FALSE);
MAKE_CONSTANT("double-0",lisp_double_0);
MAKE_CONSTANT("double-1",lisp_double_1);
MAKE_CONSTANT("long-0",lisp_long_0);
MAKE_CONSTANT("long-1",lisp_long_1);
mpz_t *lisp_mpz_1,*lisp_mpz_0;
mpfr_t *lisp_mpfr_1,*lisp_mpfr_0;
static void initPrimsObarray(obarray *ob,env* ob_env);
void initPrims(){
globalObarray=xmalloc(sizeof(obarray));
obarray_entry** global_buckets=xmalloc(128*sizeof(obarray_entry*));
*globalObarray=(obarray)
{.buckets=global_buckets,.size=128,.used=0,.entries=0,.capacity=0.0,
                .capacity_inc=(1.0/(128*10)),.gthresh=0.75,.gfactor=2,
                .is_weak_hash=0,.hash_fn=fnv_hash};
keywordObarray=xmalloc(sizeof(obarray));
obarray_entry** keyword_buckets=xmalloc(128*sizeof(obarray_entry*));
*keywordObarray=(obarray)
{.buckets=keyword_buckets,.size=128,.used=0,.entries=0,.capacity=0.0,
                .capacity_inc=(1.0/(128*10)),.gthresh=0.75,.gfactor=2,
                .is_weak_hash=0,.hash_fn=fnv_hash};
globalObarrayEnv=xmalloc(sizeof(obarray_env));
keywordObarrayEnv=xmalloc(sizeof(obarray_env));
topLevelEnv=xmalloc(sizeof(env));
globalObarrayEnv->enclosing=keywordObarrayEnv->enclosing=0;
globalObarrayEnv->head=globalObarray;
keywordObarrayEnv->head=keywordObarray;
initPrimsObarray(globalObarray,(env*)globalObarrayEnv);
*topLevelEnv=(env){.enclosing=globalObarrayEnv->enclosing,
.head={.ob=globalObarrayEnv->head},.tag=_obEnv};
mpfr_set_default_prec(256);
mp_set_memory_functions(GC_MALLOC_1,GC_REALLOC_3,GC_FREE_2);

}
static void initPrimsObarray(obarray *ob,env* ob_env){

INIT_SYMBOL(lisp_add);
INIT_SYMBOL(lisp_sub);
INIT_SYMBOL(lisp_mul);
INIT_SYMBOL(lisp_div);
INIT_SYMBOL(lisp_lt);
INIT_SYMBOL(lisp_gt);
INIT_SYMBOL(lisp_gte);
INIT_SYMBOL(lisp_lte);
INIT_SYMBOL(lisp_ne);
INIT_SYMBOL(lisp_numeq);
INIT_SYMBOL(lisp_inc);
INIT_SYMBOL(lisp_dec);
INIT_SYMBOL(lisp_sum);
INIT_SYMBOL(Cons);
INIT_SYMBOL(set_car);
INIT_SYMBOL(set_cdr);
INIT_SYMBOL(last);
INIT_SYMBOL(push_cons);
INIT_SYMBOL(pop_cons);
INIT_SYMBOL(mapcar);
INIT_SYMBOL(reduce);
INIT_SYMBOL(qsort_cons);
INIT_SYMBOL(lisp_length);
INIT_SYMBOL(lisp_iota);
INIT_SYMBOL(aref);
INIT_SYMBOL(array_to_list);
INIT_SYMBOL(lisp_typeName);
INIT_SYMBOL(typeOf);
INIT_SYMBOL(lisp_print);
INIT_SYMBOL(lisp_println);
INIT_SYMBOL(lisp_eval);
INIT_SYMBOL(lisp_open);
INIT_SYMBOL(lisp_close);
INIT_SYMBOL(lisp_fputs);
INIT_SYMBOL(lisp_fprint);
INIT_SYMBOL(lisp_fprintln);
INIT_SYMBOL(lisp_cat);
INIT_SYMBOL(lisp_getcwd);
INIT_SYMBOL(lisp_system);
INIT_SYMBOL(lisp_eq);
INIT_SYMBOL(lisp_xor);
INIT_SYMBOL(lisp_logand);
INIT_SYMBOL(lisp_logor);
INIT_SYMBOL(ash);
INIT_SYMBOL(lisp_pow);
INIT_SYMBOL(lisp_sqrt);
INIT_SYMBOL(lisp_cos);
INIT_SYMBOL(lisp_sin);
INIT_SYMBOL(lisp_tan);
INIT_SYMBOL(lisp_exp);
INIT_SYMBOL(lisp_log);
INIT_SYMBOL(lisp_abs);
INIT_SYMBOL(lisp_mod);
INIT_SYMBOL(lisp_min);
INIT_SYMBOL(lisp_max);
INIT_SYMBOL(lisp_round);
INIT_SYMBOL(lisp_randfloat);
INIT_SYMBOL(lisp_randint);
INIT_SYMBOL(lisp_bigint);
INIT_SYMBOL(lisp_bigfloat);
INIT_SYMBOL(lisp_bigint_add);
INIT_SYMBOL(lisp_bigint_sub);
INIT_SYMBOL(lisp_bigint_mul);
INIT_SYMBOL(lisp_bigint_mod);
INIT_SYMBOL(lisp_bigint_cdiv_q);
INIT_SYMBOL(lisp_bigint_fdiv_q);
INIT_SYMBOL(lisp_bigint_tdiv_q);
INIT_SYMBOL(lisp_bigint_cdiv_r);
INIT_SYMBOL(lisp_bigint_fdiv_r);
INIT_SYMBOL(lisp_bigint_tdiv_r);
INIT_SYMBOL(lisp_bigint_and);
INIT_SYMBOL(lisp_bigint_ior);
INIT_SYMBOL(lisp_bigint_xor);
INIT_SYMBOL(lisp_bigint_gt);
INIT_SYMBOL(lisp_bigint_eq);
INIT_SYMBOL(lisp_bigint_lt);
INIT_SYMBOL(lisp_bigint_ge);
INIT_SYMBOL(lisp_bigint_le);
INIT_SYMBOL(lisp_bigint_ne);
INIT_SYMBOL(lisp_bigfloat_add);
INIT_SYMBOL(lisp_bigfloat_sub);
INIT_SYMBOL(lisp_bigfloat_mul);
INIT_SYMBOL(lisp_bigfloat_div);
INIT_SYMBOL(lisp_bigfloat_pow);
INIT_SYMBOL(lisp_bigfloat_gt);
INIT_SYMBOL(lisp_bigfloat_eq);
INIT_SYMBOL(lisp_bigfloat_lt);
INIT_SYMBOL(lisp_bigfloat_ge);
INIT_SYMBOL(lisp_bigfloat_le);
INIT_SYMBOL(lisp_bigfloat_ne);
INIT_SYMBOL(lisp_arrayp);
INIT_SYMBOL(lisp_consp);
INIT_SYMBOL(lisp_numberp);
INIT_SYMBOL(lisp_nilp);
INIT_SYMBOL(lisp_symbolp);
INIT_SYMBOL(lisp_bigintp);
INIT_SYMBOL(lisp_bigfloatp);
INIT_SYMBOL(lisp_stringp);
INIT_SYMBOL(lisp_bignump);
INIT_SYMBOL(lisp_errorp);
INIT_SYMBOL(lisp_functionp);
INIT_SYMBOL(lisp_streamp);
INIT_SYMBOL(cdr);
INIT_SYMBOL(cddr);
INIT_SYMBOL(cdddr);
INIT_SYMBOL(cddddr);
INIT_SYMBOL(cdddar);
INIT_SYMBOL(cddar);
INIT_SYMBOL(cddadr);
INIT_SYMBOL(cddaar);
INIT_SYMBOL(cdar);
INIT_SYMBOL(cdadr);
INIT_SYMBOL(cdaddr);
INIT_SYMBOL(cdadar);
INIT_SYMBOL(cdaar);
INIT_SYMBOL(cdaadr);
INIT_SYMBOL(cdaaar);
INIT_SYMBOL(car);
INIT_SYMBOL(cadr);
INIT_SYMBOL(caddr);
INIT_SYMBOL(cadddr);
INIT_SYMBOL(caddar);
INIT_SYMBOL(cadar);
INIT_SYMBOL(cadadr);
INIT_SYMBOL(cadaar);
INIT_SYMBOL(caar);
INIT_SYMBOL(caadr);
INIT_SYMBOL(caaddr);
INIT_SYMBOL(caadar);
INIT_SYMBOL(caaar);
INIT_SYMBOL(caaadr);
INIT_SYMBOL(caaaar);
INIT_CONST(lisp_mach_eps);
INIT_CONST(lisp_pi);
INIT_CONST(lisp_euler);
INIT_CONST(lisp_max_long);
INIT_CONST(lisp_NIL);
INIT_CONST(lisp_LISP_TRUE);
INIT_CONST(lisp_LISP_FALSE);
INIT_CONST(lisp_double_0);
INIT_CONST(lisp_double_1);
INIT_CONST(lisp_long_0);
INIT_CONST(lisp_long_1);
}
