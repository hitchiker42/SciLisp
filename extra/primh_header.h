/*****************************************************************
 * Copyright (C) 2013 Tucker DiNapoli                            *
 * SciLisp is Licensed under the GNU General Public License V3   *
 ****************************************************************/
/* This File is automatically generated do not edit */
#ifndef __PRIM_H_
#define __PRIM_H_
#include "common.h"
#include "cons.h"
#include "array.h"
#include "print.h"
#include <time.h>
#define DEFUN_INTERN_OBARRAY(l_name,c_name)                             \
  symbol c_name ## _sym=                                                \
    (symbol){.name = l_name,.val =                                      \
             {.tag=_fun,.val={.fun = &c_name##call}},                   \
             .symbol_env=ob_env};                                      \
  symref c_name ## _ptr=&c_name##_sym;                                  \
  obarray_add_entry(ob,c_name##_ptr)

#define DEFUN_INTERN(l_name,c_name)                                       \
  global_symbol c_name ## _sym=                                         \
    (global_symbol){.name = l_name,.val =                               \
                    {.tag=_fun,.val={.fun = &c_name##call}},            \
                    .symbol_env=&topLevelEnv};                           \
  global_symref c_name ## _ptr=&c_name##_sym;                             \
  addGlobalSymMacro(c_name##_ptr)
#define INTERN_ALIAS(l_name,c_name,gensym)                                \
  global_symbol c_name ## _sym ## gensym=                                \
    (global_symbol){.name = l_name,.val =                                \
                    {.tag=_fun,.val={.fun = &c_name##call}},            \
                    .symbol_env=&topLevelEnv};                           \
  global_symref c_name ## _ptr ## gensym =&c_name##_sym##gensym;          \
  addGlobalSymMacro(c_name##_ptr##gensym)
#define DEFCONST(lisp_name,c_name)                                      \
  global_symbol c_name ## _sym={.name = lisp_name,.val = c_name};       \
  global_symref c_name ## _ptr=&c_name##_sym;                           \
  addGlobalSymMacro(c_name##_ptr);
#define DEFUN_ARGS_0	(void)
#define DEFUN_ARGS_1	(sexp)
#define DEFUN_ARGS_2	(sexp, sexp)
#define DEFUN_ARGS_3	(sexp, sexp, sexp)
#define DEFUN_ARGS_4	(sexp, sexp, sexp, sexp)
#define DEFUN_ARGS_5	(sexp, sexp, sexp, sexp,        \
                         sexp)
#define DEFUN_ARGS_6	(sexp, sexp, sexp, sexp,        \
                         sexp, sexp)
#define DEFUN_ARGS_7	(sexp, sexp, sexp, sexp,        \
                         sexp, sexp, sexp)
#define DEFUN_ARGS_8	(sexp, sexp, sexp, sexp,        \
                         sexp, sexp, sexp, sexp)
#define DEFUN_ARGS_MANY (...)
#define DEFUN(cname,numargs)                                \
  sexp cname DEFUN_ARGS_##numargs ;              \
  extern function cname ## call
#define lisp_stderr {.tag = _stream,.val={.stream=stderr}}
#define lisp_stdout {.tag = _stream,.val={.stream=stdout}}
#define lisp_stdin {.tag = _stream,.val={.stream=stdin}}
static void* GC_REALLOC_3(void* ptr,size_t old,size_t new){
  return GC_REALLOC(ptr,new);
}
static void GC_FREE_2(void* ptr,size_t size){
  return GC_FREE(ptr);
}
static void* GC_MALLOC_1(size_t size){
  return GC_MALLOC(size);
}
extern const sexp lisp_pi;
extern const sexp lisp_euler;
extern const sexp lisp_max_long;
extern const sexp lisp_mach_eps;
//create prototypes for functions in prim.c 
//so primitives can be used in the c source
